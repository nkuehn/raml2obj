/**
 * A simple, fast, incomplete alternative to the "datatype-expansion" library by raml.org
 * design goals:
 * - fast
 * - good enough for documentation, but not for other use cases like code generation
 *  - restricted nesting: types have properties, but the properties of the properties are deleted
 *
 * Unsupported:
 * - multiple inheritance
 * - no support for JSON schema or XML schema external type descriptions
 * - constraint validation
 * - constraint narrowing
 *
 * Algorithm
 * - first pull out copies of the types, type properties and annotations into separate collections
 * - remove nested properties from properties
 * - optionally enhance the types with extra information from the parser AST
 * - independently expand the parent inherited information on types, properties and annotations
 * - selectively expand and enhance (e.g. expand the contained type in array types)
 */

// TODOs:
// * align the expansion of "items" property
//   (it's expanded by the datatype-expansion, here it's a string with the type name)
//   It would have to be aligned at least structurally to not break GraphQL
// * align the way type names from libraries (with namespaceprefix) are put into name vs. key vs. displayName
// * "originalType" field on properties not as in datatype-expansion
//
const _ = require('lodash');

/*
types: array of types from the structure generated by toJSON() of the raml-1-parser
api: Api object (of the raml-1-parser) representing the full Api context.

relevant documentation:
https://raml-org.github.io/raml-js-parser-2/interfaces/_node_modules_raml_definition_system_node_modules_raml_typesystem_dist_src_nominal_interfaces_d_.itypedefinition.html
https://raml-org.github.io/raml-js-parser-2/interfaces/_node_modules_raml_definition_system_node_modules_raml_typesystem_dist_src_nominal_interfaces_d_.iproperty.html
*/
const expandTypes = (typesObj, api) => {
  // first pull out copies of the types, type properties and annotations into separate collections
  const types = {};
  for (const typeKey in typesObj) {
    types[typeKey] = _.cloneDeep(typesObj[typeKey]);
    delete types[typeKey].properties;
    delete types[typeKey].annotations;
  }

  const typeProperties = {};
  for (const typeKey in typesObj) {
    typeProperties[typeKey] = {
      properties: _.cloneDeep(typesObj[typeKey].properties),
    };
    // remove nested properties from properties
    if (typeProperties[typeKey].properties) {
      delete typeProperties[typeKey].properties.properties;
    }
  }

  const typeAnnotations = {};
  for (const typeKey in typesObj) {
    typeAnnotations[typeKey] = {
      annotations: _.cloneDeep(typesObj[typeKey].annotations),
    };
  }

  // enhance the types with extra information from the parser AST
  // - additionalProperties = true/false
  // - parentTypes = ["Account", "object", "any" ]  // TODO get rid of the parser-internal ones like "ValueType"
  // - subTypes = [ "PasswordProtectedCustomerAccount" ]
  for (const typeKey in types) {
    const typeDef = typeDefinitionByName(typeKey, api);
    const typeDecl = typeDeclarationByName(typeKey, api);
    if (typeDecl && typeof typeDecl.additionalProperties === 'function') {
      types[typeKey].additionalProperties = typeDecl.additionalProperties();
      // additional Properties defaults to true:
      // https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md#object-type
      if (types[typeKey].additionalProperties === null)
        types[typeKey].additionalProperties = true;
    }
    if (typeDef) {
      const superTypes = superTypeNames(typeKey, api);
      if (superTypes) {
        types[typeKey].superTypes = superTypes;
      }
      const subTypes = subTypeNames(typeKey, api);
      if (subTypes) {
        types[typeKey].subTypes = subTypes;
      }
    }
  }

  // build a new type with flattened inheritance
  const flatTypes = {};
  for (const typeKey in types) {
    const flatType = {};
    // expand the parent inherited information on types
    const reverseParents = _.reverse(_.cloneDeep(superTypeNames(typeKey, api)));
    for (const parentKey of reverseParents) {
      if (types[parentKey]) {
        const typeDef = typeDefinitionByName(typeKey, api);
        Object.assign(flatType, _.cloneDeep(types[parentKey]));
        flatType.originalType = parentKey;
        flatType.type = typeDef.kind()[0];
      }
    }
    const typeDef = typeDefinitionByName(typeKey, api);
    Object.assign(flatType, _.cloneDeep(types[typeKey]));
    if (!typeDef.isValueType()) {
      flatType.type = typeDef.kind()[0];
    }

    flatTypes[typeKey] = flatType;
  }

  // build the flattened inheritance on properties
  const flatTypeProperties = {};
  for (const typeKey in types) {
    const parentNames = _.reverse(_.cloneDeep(superTypeNames(typeKey, api)));
    flatTypeProperties[typeKey] = { properties: {} };
    // TODO at this point use (or later check against) "allProperties" from the parser?
    for (const parentName of parentNames) {
      const parentType = typeProperties[parentName];
      if (parentType && parentType.properties) {
        for (const parentPropKey in parentType.properties) {
          const parentProp = parentType.properties[parentPropKey];
          setOrMixInProp(
            flatTypeProperties[typeKey].properties,
            parentProp,
            parentPropKey
          );
        }
      }
    }
    for (const ownPropKey in typeProperties[typeKey].properties) {
      const ownProp = typeProperties[typeKey].properties[ownPropKey];
      setOrMixInProp(
        flatTypeProperties[typeKey].properties,
        ownProp,
        ownPropKey
      );
    }
    if (Object.keys(flatTypeProperties[typeKey].properties).length === 0) {
      delete flatTypeProperties[typeKey].properties;
    }
  }

  // inside the properties, flatten the type of the property and the specifics set on the property definition
  // ,keeping the type information in "originalType"
  for (const typeKey in flatTypeProperties) {
    const typeProps = flatTypeProperties[typeKey].properties;
    if (typeProps) {
      for (const propKey in typeProps) {
        const prop = typeProps[propKey];
        const originalType = prop.type[0]; // no unions or stuff supported.
        const propType = flatTypes[originalType];
        if (propType) {
          typeProps[propKey] = Object.assign(_.cloneDeep(propType), prop);
          typeProps[propKey].type = propType.type[0];
          typeProps[propKey].originalType = originalType;
        }
      }
    }
  }

  // TODO build flattened inheritance on annotations
  // const flatTypeAnnotations = {};

  // set flatProperties back into the flatTypes
  for (const typeKey in flatTypes) {
    if (
      flatTypeProperties[typeKey].properties &&
      Object.keys(flatTypeProperties[typeKey].properties).length > 0
    ) {
      flatTypes[typeKey].properties = flatTypeProperties[typeKey].properties;
    }
  }

  // expand "items" (of array types) with flatType with properties, also in properties
  for (const typeKey in flatTypes) {
    const type = flatTypes[typeKey];
    expandItems(type, flatTypes);
    for (const propKey in type.properties) {
      // expand the array contained items
      expandItems(type.properties[propKey], flatTypes);
    }
  }

  // TODO set flatAnnotations back into the flatTypes
  // for(let typeKey in flatTypes){
  //   if(Object.keys(flatTypeProperties[typeKey].annotations).length === 0){
  //     flatTypes[typeKey].annotations = flatTypeProperties[typeKey].annotations
  //   }
  // }

  return flatTypes;
};

const setOrMixInProp = (targetObj, obj, propName) => {
  if (targetObj.hasOwnProperty(propName)) {
    Object.assign(targetObj[propName], _.cloneDeep(obj));
  } else {
    targetObj[propName] = _.cloneDeep(obj);
  }
};

const expandItems = (type, types) => {
  if (type.items && typeof type.items === 'string') {
    const itemsObj = types[type.items];
    type.items = itemsObj
      ? itemsObj
      : {
          name: type.items,
        };
  }
};

const typeDeclarationByName = (name, api) => {
  return api.types().find(t => t.name() === name);
};

const typeDefinitionByName = (name, api) => {
  const typeDecl = typeDeclarationByName(name, api);
  return typeDecl ? typeDecl.runtimeDefinition() : undefined;
};

const superTypeNames = (typeKey, api) => {
  const typeDef = typeDefinitionByName(typeKey, api);
  if (typeDef) {
    return typeDef.allSuperTypes().map(typeDef => {
      return typeDef.nameId();
    });
  }
  return null;
};

const subTypeNames = (typeKey, api) => {
  const typeDef = typeDefinitionByName(typeKey, api);
  if (typeDef) {
    return typeDef.allSubTypes().map(typeDef => {
      return typeDef.nameId();
    });
  }
  return null;
};

module.exports = {
  expandTypes,
};
