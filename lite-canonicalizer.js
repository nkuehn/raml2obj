// A simple, fast, incomplete alternative to the "datatype-expansion" library by raml.org
// It flattens the inherited properties of a type into the type itself.
// It can be necessary to use this if "datatype-expansion" is too slow, too memory-intensive
// and/or not capable of handling the type structure (e.g. in recursive type structures)
// E.g. it does not support:
// - no RAML Library support
// - "originalType" field not implemented (denotes the parent)
// - multiple inheritance and union types (TODO maybe the latter actually work)
// - constraint validation
// - constraint narrowing
// - "additionalProperties" is not available
// - no support for JSON schema or XML schema external type descriptions
// - more things, this list is long: https://github.com/raml-org/datatype-expansion/blob/6f1db08f1ff41c8ece51202c81462291b67d6377/doc/algorithms.md
const _ = require('lodash')

/*
types: array of types from the structure generated by toJSON() of the raml-1-parser
api: Api object (of the raml-1-parser) representing the full Api context.

relevant documentation:
https://raml-org.github.io/raml-js-parser-2/interfaces/_node_modules_raml_definition_system_node_modules_raml_typesystem_dist_src_nominal_interfaces_d_.itypedefinition.html
https://raml-org.github.io/raml-js-parser-2/interfaces/_node_modules_raml_definition_system_node_modules_raml_typesystem_dist_src_nominal_interfaces_d_.iproperty.html
*/
const expandTypes = (types, api) => {

  const canonicalTypes = {}
  _.forOwn(types, (type, key) => {
    const typeDef = typeDefinitionByName(type.name, api)
    if(!typeDef) {
      console.log(`lite-canonicalizer: could not find type definition for ${type.name} in api parser`)
      return
    }

    const parentTypes = typeDef.allSuperTypes().map(typeDef => {
      return typeObjByName(typeDef.nameId(), types)
    }).filter(t => !_.isUndefined(t))
    _.reverse(parentTypes)

    const canonical = { _newProperties: {} }
    for (const parent of parentTypes){
      mixInDescendant(canonical, parent)
    }
    mixInDescendant(canonical, type)
    canonical.properties = canonical._newProperties
    _.unset(canonical, "_newProperties")
    if(canonical.properties == {}) _.unset(canonical, "properties")
    // canonical.rawType = type

    canonicalTypes[key] = canonical
  });
  return canonicalTypes
}

const mixInDescendant = (target, descendant) => {
  if (!_.has(target, "_newProperties")) target._newProperties = {}
  _.assign(target, descendant)
  _.forOwn(descendant.properties, (property, key) => {
    if (_.has(target._newProperties, key)) {
      _.assign(target._newProperties[key], property)
    } else {
      target._newProperties[key] = _.cloneDeep(property)
    }
  })
  return target
}

const typeDeclarationByName = (name, api) => {
  return api.types().find(t => t.name() === name)
}
const typeDefinitionByName = (name, api) => {
  typeDecl = typeDeclarationByName(name, api)
  return typeDecl ? typeDecl.runtimeDefinition() : undefined
}
const typeObjByName = (name, types) => {
  if (_.isPlainObject(types)) {
    return types[name]
  } else if (_.isArray(types)) {
    return types.find(t => { return t.name === name })
  } else {
    return types[name]
  }
}

module.exports = {
  expandTypes
}
