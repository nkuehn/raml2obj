// A simple, fast, incomplete alternative to the "datatype-expansion" library by raml.org
// It flattens the inherited properties of a type into the type itself.
// It can be necessary to use this if "datatype-expansion" is too slow, too memory-intensive
// and/or not capable of handling the type structure (e.g. in recursive type structures)
// E.g. it does not support:
// - multiple inheritance and union types (TODO maybe the latter actually work)
// - constraint validation
// - constraint narrowing
// - no support for JSON schema or XML schema external type descriptions
// - likely more things, this list is long: https://github.com/raml-org/datatype-expansion/blob/6f1db08f1ff41c8ece51202c81462291b67d6377/doc/algorithms.md
//
// TODOs (things we'll need to fix here)
// * align the expansion of "items" property
//   (it's expanded by the datatype-expansion, here it's a string with the type name)
//   It would have to be aligned at least structurally to not break GraphQL
// * align the way type names from libraries (with namespaceprefix) are put into name vs. key vs. displayName
// * "additionalProperties" true/false is not on the response, if the parser provides that we should add it
// * "originalType" field not implemented (denotes the parent or self if not user defined parent is there)
//
const _ = require('lodash');

/*
types: array of types from the structure generated by toJSON() of the raml-1-parser
api: Api object (of the raml-1-parser) representing the full Api context.

relevant documentation:
https://raml-org.github.io/raml-js-parser-2/interfaces/_node_modules_raml_definition_system_node_modules_raml_typesystem_dist_src_nominal_interfaces_d_.itypedefinition.html
https://raml-org.github.io/raml-js-parser-2/interfaces/_node_modules_raml_definition_system_node_modules_raml_typesystem_dist_src_nominal_interfaces_d_.iproperty.html
*/
const expandTypes = (types, api) => {
  // pass one: enhance orginal structure:
  _.forOwn(types, type => {
    expandItems(type, types);
    if (type.properties) {
      _.forEach(type.properties, prop => {
        expandItems(prop, types);
      });
    }
  });

  // important: the canonical structure is fresh object into which data is
  // writen only as full clones.  This way it remains possible to always pick the non-expanded
  // types from the "types" object to avoid random recursions and deep expansions
  const canonicalTypes = {};

  _.forOwn(types, (type, key) => {
    const typeDef = typeDefinitionByName(type.name, api);
    if (!typeDef) {
      console.log(
        `lite-canonicalizer: could not find type definition for ${
          type.name
        } in api parser`
      );
      return;
    }

    const parentTypes = typeDef
      .allSuperTypes()
      .map(typeDef => {
        return typeObjByName(typeDef.nameId(), types);
      })
      .filter(t => !_.isUndefined(t));
    _.reverse(parentTypes);

    const canonical = { _newProperties: {} };
    for (const parent of parentTypes) {
      mixInDescendant(canonical, parent);
    }
    mixInDescendant(canonical, type);
    canonical.properties = canonical._newProperties;
    _.unset(canonical, '_newProperties');

    if (canonical.properties === {}) _.unset(canonical, 'properties');
    // canonical.rawType = type

    canonicalTypes[key] = canonical;
  });

  const canonicalTypesUnexpanded = _.cloneDeep(canonicalTypes);
  _.forOwn(canonicalTypes, canonical => {
    expandItems(canonical, canonicalTypesUnexpanded);
    _.forEach(canonical.properties, prop => {
      expandItems(prop, canonicalTypesUnexpanded);
    });
  });
  return canonicalTypes;
};

const mixInDescendant = (target, descendant) => {
  if (!_.has(target, '_newProperties')) target._newProperties = {};
  _.assign(target, descendant);
  _.forOwn(descendant.properties, (property, key) => {
    if (_.has(target._newProperties, key)) {
      _.assign(target._newProperties[key], property);
    } else {
      target._newProperties[key] = _.cloneDeep(property);
    }
  });
  return target;
};

const expandItems = (type, types) => {
  if (type.items && typeof type.items === 'string') {
    const typeObj = typeObjByName(type.items, types);
    type.items = typeObj ? typeObj : { type: type.items };
  }
};

const typeDeclarationByName = (name, api) => {
  return api.types().find(t => t.name() === name);
};
const typeDefinitionByName = (name, api) => {
  const typeDecl = typeDeclarationByName(name, api);
  return typeDecl ? typeDecl.runtimeDefinition() : undefined;
};
const typeObjByName = (name, types) => {
  if (_.isPlainObject(types)) {
    return types[name];
  } else if (_.isArray(types)) {
    return types.find(t => {
      return t.name === name;
    });
  } else {
    return types[name];
  }
};

module.exports = {
  expandTypes,
};
